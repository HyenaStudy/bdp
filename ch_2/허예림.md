## Chapter 2 객체 지향 프로그래밍 패러다임

### 2.1 객체 지향이란?

객체 지향이란 캡슐화, 추상화, 상속, 다형성의 특성을 가지는 것 이상의 개념을 포함하고 있다.

**객체지향 프로그래밍, 객체지향 프로그래밍 언어**

- 객체 지향 프로그래밍: 프로그래밍 패러다임 또는 프로그래밍 스타일로 코드를 구성하는 기본 단위로 클래스 또는 객체를 사용하고, 코드 설계와 구현의 초석으로 캡슐화, 추상화, 상속, 다형성등의 4가지 특성을 사용한다.
- 객체지향 프로그래밍 언어: 클래스 또는 객체 문법을 지원하며 이 문법은 객체 지향 프로그래밍의 4가지 특성인 캡슐화, 추상화, 상속, 다형성을 쉽게 구현할 수 있다.
- 객체지향 프로그래밍과 객체지향 프로그래밍언어는 필요충분은 아니다.
- smalltalk
    - 클래스와 객체를 처음 사용한 객체지향 프로그래밍 언어

**Rough한 객체 지향 프로그래밍 언어**

- is-a 클래스 : 객체지향에서 상속관계를 표현하기 위한 단어
- A가 B의 일종이다. 자식 클래스 is a 부모클래스
- dog **is a(n)** animal / Car **is a** vehicle
- is-a 관계가 성립하면 상속 관계를 고려해볼 수 있다.
- 하지만 논리적으로 맞다고 해서 상속관계로 정의할 경우 많은 어려움을 야기 할 수 있다.
- 따라서 Go언어와 같은 많은 프로그래밍 언어는 설계 과정에서 상속 기능을 포기했다.
- 그럼에도 프로그래밍 언어가 클래스 또는 객체의 문법적 개념을 지원하고, 이를 코드 구성의 기본 단위로 사용하는 한 단순히 객체지향 프로그래밍 언어로 간주될 수 있다.

**OOA(분석)와 OOD(정의)**

- OOA와 OOD는 이름에서 알 수 있듯 객체나 클래스를 대상으로 한 분석과 설계를 한다.
- 분석과 설계를 통해 프로그램이 어떤 클래스들로 구성되었는 지 각각이 어떤 메서드와 속성을 지는 지 등을 구체적으로 구현할 수 있다.
- 이러한 특징이 객체지향의 가장 큰 장점이다.

**UML에 대한 참고사항**

- 객체지향이나 디자인 패턴을 설명할 때, **설계 아이디어를 쉽게 보여주려고 UML을 쓴다**.
- 클래스 다이어그램, 유스 케이스, 시퀀스, 액티비티 등등 다양한 다이어그램이 UML에 속한다.
- 완벽한 UML은 오히려 실무에서 큰 이익을 가져다 주지 못한다. 때문에 책에서 단순화한 UML 구조를 제공한다.

"UML은 배우기 어렵고, 실제로 객체지향 분석과 객체지향 설계에 사용하는 것이 권장되지 않는다고 언급했는데, 이에 대해 왜 그런지 생각해보자.”

→ UML은 구조화된 시각적 도구, 객체지향에서는 변경 가능성, 변화를 받아들 일 수 있는 유연함을 강조한다. 정적인 것과 동적임?

2. "《GoF의 디자인 패턴》은 고전적인 디자인 패턴 책이다. 이 책의 제목이 객체지향을 구체적으로 언급한 이유에 대해 생각해보자.”

→ 안읽어봐서 모름

### 2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유

**캡슐화**

- 데이터에 직접 접근하지 못하게 하고, 메서드를 통해서만 값을 다룰 수 있도록 하여 잘못된 데이터 변경을 방지하고 객체의 안정성을 확보하기 위해 등장했다. 예를 들어 Wallet 클래스에서는 balance, id, createTime 같은 필드를 외부에서 직접 수정할 수 없고, increaseBalance나 decreaseB
- 내부 구현을 외부에 노출하지 않음으로써 변경 가능성을 줄이고, 유지보수를 쉽게 만들기 위해 필요하다. 클래스의 데이터 구조가 바뀌어도 외부에 영향을 주지 않도록 하려면 캡슐화가 필수다.
- 객체가 자신의 상태를 스스로 보호하게 만들고, 특정 로직 외에는 객체 내부 상태를 변경하지 못하도록 강제할 수 있다. 이로써 객체지향의 핵심인 **자율적인 객체 설계**가 가능해진다.
    
    ```jsx
    public void increaseBalance(BigDecimal increasedAmount) {
        this.balance.add(increasedAmount);
        this.balanceLastModifiedTime = System.currentTimeMillis();
    }
    ```
    
- 이처럼 setter를 제공하지 않고, 필요한 기능만 메서드로 제공함으로써 잘못된 사용이나 예기치 않은 변경을 막는다. 예를 들어 createTime 은 생성 시에만 초기화되며 이후에는 변경되지 않도록 설계되었다.

**추상화**

- 복잡한 구현을 숨기고 중요한 개념만 외부에 노출하여, 사용자가 내부 동작을 몰라도 객체를 사용할 수 있게 만들기 위해 등장했다. 인터페이스나 추상 클래스는 이 역할을 담당하며, 사용자는 구현체에 신경 쓰지 않고 기능에만 집중할 수 있다.
    
    ```jsx
    public interface IPictureStorage {
        void savePicture(Picture picture);
    }
    
    public class PictureStorage implements IPictureStorage {
        public void savePicture(Picture picture) { ... }
    }
    
    ```
    
    클라이언트 코드는 PictureStorage의 내부 구현을 몰라도 IPictureStorage 인터페이스를 통해 저장 기능을 사용할 수 있다. 이로 인해 구현 교체가 자유로워지고 테스트 용이성도 높아진다.
    
- 기능 중심의 설계를 가능하게 하여 구현체 교체, 기능 확장, 테스트 용이성 등에서 유리한 구조를 만든다. 실제로 다양한 구현체가 존재해도 클라이언트는 추상화된 인터페이스만 의존하므로 변경에 유연하다.
- 추상화 없이는 객체 간의 **역할 기반 설계**나 **유연한 확장**이 어려워지며, 객체를 단순히 구현물로만 보게 되는 한계가 생긴다. 따라서 추상화는 객체지향에서 **기능 중심의 설계**를 가능하게 하는 핵심 요소다.

**상속**

- 공통 기능을 상위 클래스에 두고, 여러 하위 클래스가 이를 물려받아 중복 코드를 줄이고 재사용성을 높이기 위해 등장했다. 비슷한 메서드를 여러 곳에 반복하지 않고 공통화할 수 있다.
    
    ```jsx
    public class SortedDynamicArray extends DynamicArray {
        @Override
        public void add(Integer e) {
            // 정렬되게 삽입하는 로직
        }
    }
    
    ```
    
- 객체 간의 일반화 관계, 즉 "is-a" 관계를 표현하여 개념적으로 명확한 모델링을 가능하게 한다. 예를 들어, 고양이는 동물이다 같은 관계를 코드로 표현할 수 있다.
- 상속은 자칫 설계를 복잡하게 만들 수 있고, 잘못 사용하면 상위 클래스에 지나치게 의존하게 되어 유지보수가 어려워진다. 하지만 적절히 사용하면 **계층 구조를 통한 개념의 정리**와 **구조적 일관성 유지**에 큰 도움이 된다.

**다형성**

- 동일한 메서드 이름으로 다양한 객체를 처리할 수 있도록 하여, 코드의 유연성과 재사용성을 높이기 위해 등장했다. 예를 들어 print(iterator)처럼 하나의 메서드로 다양한 객체를 순회할 수 있다.
- 조건문 없이 각 객체에 맞는 기능을 알아서 실행할 수 있게 해주므로, 코드가 단순해지고 확장도 쉬워진다. 새로운 기능을 추가해도 기존 코드를 수정할 필요가 없다.
- 다형성은 **인터페이스 기반 설계**, **전략 패턴**, **템플릿 메서드 패턴** 같은 객체지향 설계의 기초가 된다. 다형성이 없으면 다양한 객체를 하나의 방식으로 다루는 객체지향의 강점을 살릴 수 없다.
    
    ```jsx
    public static void print(Iterator iterator) {
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
    
    ```
