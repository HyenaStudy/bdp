## Chapter 2 객체 지향 프로그래밍 패러다임

### 2.1 객체 지향이란?

객체 지향이란 캡슐화, 추상화, 상속, 다형성의 특성을 가지는 것 이상의 개념을 포함하고 있다.

**객체지향 프로그래밍, 객체지향 프로그래밍 언어**

- 객체 지향 프로그래밍: 프로그래밍 패러다임 또는 프로그래밍 스타일로 코드를 구성하는 기본 단위로 클래스 또는 객체를 사용하고, 코드 설계와 구현의 초석으로 캡슐화, 추상화, 상속, 다형성등의 4가지 특성을 사용한다.
- 객체지향 프로그래밍 언어: 클래스 또는 객체 문법을 지원하며 이 문법은 객체 지향 프로그래밍의 4가지 특성인 캡슐화, 추상화, 상속, 다형성을 쉽게 구현할 수 있다.
- 객체지향 프로그래밍과 객체지향 프로그래밍언어는 필요충분은 아니다.
- smalltalk
    - 클래스와 객체를 처음 사용한 객체지향 프로그래밍 언어

**Rough한 객체 지향 프로그래밍 언어**

- is-a 클래스 : 객체지향에서 상속관계를 표현하기 위한 단어
- A가 B의 일종이다. 자식 클래스 is a 부모클래스
- dog **is a(n)** animal / Car **is a** vehicle
- is-a 관계가 성립하면 상속 관계를 고려해볼 수 있다.
- 하지만 논리적으로 맞다고 해서 상속관계로 정의할 경우 많은 어려움을 야기 할 수 있다.
- 따라서 Go언어와 같은 많은 프로그래밍 언어는 설계 과정에서 상속 기능을 포기했다.
- 그럼에도 프로그래밍 언어가 클래스 또는 객체의 문법적 개념을 지원하고, 이를 코드 구성의 기본 단위로 사용하는 한 단순히 객체지향 프로그래밍 언어로 간주될 수 있다.

**OOA(분석)와 OOD(정의)**

- OOA와 OOD는 이름에서 알 수 있듯 객체나 클래스를 대상으로 한 분석과 설계를 한다.
- 분석과 설계를 통해 프로그램이 어떤 클래스들로 구성되었는 지 각각이 어떤 메서드와 속성을 지는 지 등을 구체적으로 구현할 수 있다.
- 이러한 특징이 객체지향의 가장 큰 장점이다.

**UML에 대한 참고사항**

- 객체지향이나 디자인 패턴을 설명할 때, **설계 아이디어를 쉽게 보여주려고 UML을 쓴다**.
- 클래스 다이어그램, 유스 케이스, 시퀀스, 액티비티 등등 다양한 다이어그램이 UML에 속한다.
- 완벽한 UML은 오히려 실무에서 큰 이익을 가져다 주지 못한다. 때문에 책에서 단순화한 UML 구조를 제공한다.

"UML은 배우기 어렵고, 실제로 객체지향 분석과 객체지향 설계에 사용하는 것이 권장되지 않는다고 언급했는데, 이에 대해 왜 그런지 생각해보자.”

→ UML은 구조화된 시각적 도구, 객체지향에서는 변경 가능성, 변화를 받아들 일 수 있는 유연함을 강조한다. 정적인 것과 동적임?

2. "《GoF의 디자인 패턴》은 고전적인 디자인 패턴 책이다. 이 책의 제목이 객체지향을 구체적으로 언급한 이유에 대해 생각해보자.”

→ 안읽어봐서 모름

### 2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유

**캡슐화**

- 데이터에 직접 접근하지 못하게 하고, 메서드를 통해서만 값을 다룰 수 있도록 하여 잘못된 데이터 변경을 방지하고 객체의 안정성을 확보하기 위해 등장했다. 예를 들어 Wallet 클래스에서는 balance, id, createTime 같은 필드를 외부에서 직접 수정할 수 없고, increaseBalance나 decreaseB
- 내부 구현을 외부에 노출하지 않음으로써 변경 가능성을 줄이고, 유지보수를 쉽게 만들기 위해 필요하다. 클래스의 데이터 구조가 바뀌어도 외부에 영향을 주지 않도록 하려면 캡슐화가 필수다.
- 객체가 자신의 상태를 스스로 보호하게 만들고, 특정 로직 외에는 객체 내부 상태를 변경하지 못하도록 강제할 수 있다. 이로써 객체지향의 핵심인 **자율적인 객체 설계**가 가능해진다.
    
    ```jsx
    public void increaseBalance(BigDecimal increasedAmount) {
        this.balance.add(increasedAmount);
        this.balanceLastModifiedTime = System.currentTimeMillis();
    }
    ```
    
- 이처럼 setter를 제공하지 않고, 필요한 기능만 메서드로 제공함으로써 잘못된 사용이나 예기치 않은 변경을 막는다. 예를 들어 createTime 은 생성 시에만 초기화되며 이후에는 변경되지 않도록 설계되었다.

**추상화**

- 복잡한 구현을 숨기고 중요한 개념만 외부에 노출하여, 사용자가 내부 동작을 몰라도 객체를 사용할 수 있게 만들기 위해 등장했다. 인터페이스나 추상 클래스는 이 역할을 담당하며, 사용자는 구현체에 신경 쓰지 않고 기능에만 집중할 수 있다.
    
    ```jsx
    public interface IPictureStorage {
        void savePicture(Picture picture);
    }
    
    public class PictureStorage implements IPictureStorage {
        public void savePicture(Picture picture) { ... }
    }
    
    ```
    
    클라이언트 코드는 PictureStorage의 내부 구현을 몰라도 IPictureStorage 인터페이스를 통해 저장 기능을 사용할 수 있다. 이로 인해 구현 교체가 자유로워지고 테스트 용이성도 높아진다.
    
- 기능 중심의 설계를 가능하게 하여 구현체 교체, 기능 확장, 테스트 용이성 등에서 유리한 구조를 만든다. 실제로 다양한 구현체가 존재해도 클라이언트는 추상화된 인터페이스만 의존하므로 변경에 유연하다.
- 추상화 없이는 객체 간의 **역할 기반 설계**나 **유연한 확장**이 어려워지며, 객체를 단순히 구현물로만 보게 되는 한계가 생긴다. 따라서 추상화는 객체지향에서 **기능 중심의 설계**를 가능하게 하는 핵심 요소다.

**상속**

- 공통 기능을 상위 클래스에 두고, 여러 하위 클래스가 이를 물려받아 중복 코드를 줄이고 재사용성을 높이기 위해 등장했다. 비슷한 메서드를 여러 곳에 반복하지 않고 공통화할 수 있다.
    
    ```jsx
    public class SortedDynamicArray extends DynamicArray {
        @Override
        public void add(Integer e) {
            // 정렬되게 삽입하는 로직
        }
    }
    
    ```
    
- 객체 간의 일반화 관계, 즉 "is-a" 관계를 표현하여 개념적으로 명확한 모델링을 가능하게 한다. 예를 들어, 고양이는 동물이다 같은 관계를 코드로 표현할 수 있다.
- 상속은 자칫 설계를 복잡하게 만들 수 있고, 잘못 사용하면 상위 클래스에 지나치게 의존하게 되어 유지보수가 어려워진다. 하지만 적절히 사용하면 **계층 구조를 통한 개념의 정리**와 **구조적 일관성 유지**에 큰 도움이 된다.

**다형성**

- 동일한 메서드 이름으로 다양한 객체를 처리할 수 있도록 하여, 코드의 유연성과 재사용성을 높이기 위해 등장했다. 예를 들어 print(iterator)처럼 하나의 메서드로 다양한 객체를 순회할 수 있다.
- 조건문 없이 각 객체에 맞는 기능을 알아서 실행할 수 있게 해주므로, 코드가 단순해지고 확장도 쉬워진다. 새로운 기능을 추가해도 기존 코드를 수정할 필요가 없다.
- 다형성은 **인터페이스 기반 설계**, **전략 패턴**, **템플릿 메서드 패턴** 같은 객체지향 설계의 기초가 된다. 다형성이 없으면 다양한 객체를 하나의 방식으로 다루는 객체지향의 강점을 살릴 수 없다.
    
    ```jsx
    public static void print(Iterator iterator) {
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
    
    ```
### 2.3 객체지향 분석, 객체지향 설계, 객체 지향 프로그래밍을 수행하는 방법

**객체지향 분석의 세가지 단계**

- 객체 지향 분석
- 객체 지향 설계
- 객체 지향 프로그래밍

### 2.4 객체지향 프로그래밍, 절차적 프로그래밍, 함수형 프로그래밍의 차이

**절차적 프로그래밍**

- 프로그래밍 패러다임 중 하나
- 코드를 구성하기 위한 기본 단위로 메서드, 기능, 연산자처럼 절차가 필요하며 멤버 변수 속성과 같은 데이터가 메서드와 분리되어 있는 것이 특징
- 순서대로 실행되는 메서드들을 나열하여 데이터를 조작하고, 이를 통해 기능을 구현하는 프로그래밍 스타일
- 마찬가지로 절차적 프로그래밍언어를 사용한다고 해서 절차적 프로그래밍을 하는 것은 아님

**객체지향 vs 절차지향**

- 객체지향 프로그래밍은 대규모의 복잡한 프로그램 개발에 더 적합하다.
    - 요구 사항이 간단하고 전체 작업 흐름이 일직선 형태를 띄는 경우 절차지향을 통해 개발하는 것이 더 빠를 수 있다. (단계별/순차별 실행에 유리)
    - 클래스 관점에서 생각하여 복잡한 프로세스를 클래스 간의 상호작용을 통해 설계할 수 있다.
- 객체지향 프로그래밍 스타일 코드는 재사용, 확장, 유지 관리가 쉽다.
    - 객체지향 프로그래밍이 제공하는 캡슐화, 추상화, 상속, 다형성은 복잡한 프로그래밍 요구사항을 만족시킬 뿐 아니라 재사용, 확장, 유지 관리를 쉽게 한다.
- 객체 지향 프로그래밍 언어는 더 사용자 친화적이고 고급 언어이며 지능적이다.
    - 객체지향 프로그래밍의 모델링 방식이 실세계를 클래스로 매핑하는 방식

### 2.5 객체지향 프로그래밍 처럼 보이지만 실제로는 절차적 프로그래밍

**getter, setter 남용**

- 무의미한 getter와 setter의 사용은 캡슐화를 위반
- 자바에서는 Collections.unmodifiableList() 메서드를 통해 getter 메서드가 수정 불가능한 UnmodifiableList 컬렉션을 반환하도록 할 수 있으며, UnmodifiableList는 add(), clear()와 같이 데이터 수정과 관련된 메서드를 호출할 경우 UnsupportedOperaionExceptio 예외를 발생시키기 때문에 컬렉션의 데이터가 수정되는 것을 방지할 수 있다.
    - Collections.unmodifiableList() :
        - unmodifiableList의 불변셩
            - unmodifiableList가 완전한 불변성을 보장하지 않는 이유는 이 메서드가 단지 리스트에 대한 수정 작업을 막는 래퍼를 제공할 뿐, 내부 데이터 자체를 복사하거나 보호하지 않기 떄문이다.
            - Collections.unmodifiableList(originalList)는 내부적으로 originalList를 그대로 사용하며, **내용을 복사하지 않는다**. 즉, 원본 리스트가 변경되면 **unmodifiableList도 함께 영향을 받는다**.
            - 원본 리스트에 대한 참조를 여전히 가지고 있으며, 그것을 통해 데이터를 변경할 수 있다. 이 경우 unmodifiableList도 바뀐 내용을 그대로 노출하게 된다.
                1. **내부 요소가 가변 객체인 경우 더 위험하다**
                    
                    리스트 자체는 수정이 안 되더라도, 리스트 안의 객체가 가변 객체면 그 객체의 상태는 여전히 바뀔 수 있다. 예를 들어 List<User>가 있다면, 각 User의 필드는 여전히 수정 가능하다.
                    
                    진정한 의미의 불변 리스트를 원한다면, 불변 컬렉션(예: Java 9의 List.of() 또는 외부 라이브러리 like Guava ImmutableList)를 사용 or 방어적 복사 수행 unmodifiableList(new ArratList<>(internalList))
                    
    - UnsuppportedOperationException() : 특정 객체가 지원하지 않는 연산을 시도할 때 발생하는 런타임 예외, 주로 읽기 전용 컬렉션이나 고정된 컬렉션에서 수정작업을 시도할 때 발생
        - 런타임 예외의 하위 클래스이기 때문에 컴파일 시점에서는 에러가 발생하지 않고 실행 중 예외 발생 따라서 컬렉션이 불변인지 여부를 미리하거나 try-catch 사용이 필요하다.
        - 일번적으로 메서드가 명세상은 존재하지만 구현상 허용되지 않는 기능일 때 사용
        

**전역 변수와 전역 메서드의 남용**

- 전역 변수
    - 객체 지향 프로그래밍에서의 전역 변수에는 싱글턴 클래스 객체, 정적 멤버 변수, 상수가 포함되며 일반적인 적역 메서드에는 정적 메서드가 포함된다.
- 전역 메서드
    - Constants, Utils 클래스
- 광범위한 Constans클래스의 사용은 유지 보수에 영향을 미친다
    - 지속적인 상수 추가로 클래스가 비대해짐
- 코드의 컴파일 시간을 증가시킨다.
- 코드의 재사용에도 영향을 미친다.
    - 일부 상수만 사용하더라도 Constant 전체를 도입해야함
- 따라서 기능에 따라 Constans를 분리하여 클래스의 응집력과 코드의 재사용성을 향상 시킨다.

**데이터와 메서드 분리로 클래스 정의하기**

- 빈약한 도메인 모델 (Anemic Domain Model)
    - 객체 지향 설계 원칙에 어긋나는 방식으로 도메인 모델이 구성된 상태를 의미한다.
    - 이 모델에서는 도메인 객체가 데이터만 보유하고 있고, 해당 데이터에 대한 비즈니스 로직은 별도의 서비스 객체나 헬퍼 클래스에 위치해 있다. 즉, 도메인 객체는 행위를 거의 포함하지 않으며 단순히 데이터 컨테이너 역할만 수행한다.
    - 참고 : https://brightmarbles.io/blog/problem-with-anemic-domain-models/

### 2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위배하는가?

- 도메인 주도 설계(Domain-Driven Design)
    - 복잡한 소프트웨어 시스템을 개발할 때 도메인에 집중하여 소프트웨어를 설계하는 방식
    - DDD는 유비쿼터스 언어 바운디드 컨텍스트, 애그리거트와 같은 개념을 통해 도메인 지식의 왜곡을 방지하고 시스템에 명확하게 반영합니다.
        - 도메인 : 소프트웨어가 해결하려는 문제 영역 자체, 쇼핑몰 시스템의 경우 상품, 주문, 결상품, 주문, 결제 같은 것들이 도메인의 일부
        - 모델 : 도메인을 추상화한 것으로 코드 뿐만 아니라 개발자와 도메인 전문가 사이의 공통된 이해 모델
        - 유비쿼터스 언어 : 모든 구성원이 공유하는 공통 언어. 도메인 전문가, 개발자, 테스터가 같은 단어를 같은 의미로 사용.
        - 바운디드 컨텍스트 : 도메인은 크고 복잡하므로 하나의 모델로 표현하기 어렵기 때문에 의미적으로 독립된 하위 영역으로 나눈다. 이 하위 영역이 바운디드 컨텍스트.
        - 엔티티 : 고유한 식별자를 가지고 있으며 생애 주기 동안 상태가 바뀌더라도 동일성이 유지되는 객체
        - 애그리거트: 엔티티와 밸류 오브젝트의 집합으로, 일관성을 유지해야 하는 경계를 가진다. 애그리거트 루트는 외부에서 접근 가능한 유일한 엔티티이며, 나머지 구성요소는 루트를 통해서만 접근한다.
    - 도메인 주도 설계는 유지 보수성과 확장성이 높고 협업 효율이 좋아지는 장점이 있지만 초기 학습 난이도가 높도 조직 내의 깊은 도메인 이해와 협업이 요구된다는 단점이 존재한다.
- 안티 패턴
    - 소프트웨어 개발 과정에서 자주 보이지만 결과적으로는 해로운 설계 또는 구현 방식
    - 시간이 지남에 따라 유지보수성, 확장성, 테스트 용이성 등에서 문제 발생
    - 예 : 빈약한 도메인 모델, 스파게티 코드, 신의 객체, 무분별한 싱글톤 패턴 남용, 과도한 상속
