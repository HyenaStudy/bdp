# 상속과 합성

처음 자바를 공부하고, 객체지향 개념을 어렴풋이 익히며 SOLID가 뭐의 약자인지 끙끙거리면서 외울 때에는 **상속**이 신기하게만 느껴졌었으나, 몇 번의 토이 프로젝트와 사이드 프로젝트를 거치면서 생각보다 불편하다는 걸 느끼게 됐었다.
코드를 재정의하고 뭔가 다형성을 실현해야지! 하지만 뭔가 다형성에 입각한 코드 설계라기보단 그냥 외부 레퍼런스를 보고 모방하는 느낌밖에 없었다. 단순히 이론을 아는 것과 이론을 깊게 이해하고 실제의 동작을 확인하는 것은 차이가 컸다.

마침 이번에 스터디하려는 세션에서 상속과 합성을 비교하는 주제가 있어서 해당 교재를 바탕으로 내 나름대로의 여러 실험들도 해보면서 상속과 합성의 특성들에 대해 비교하고 뭘 고찰하며, 어떻게 실질적으로 적용할 수 있을까에 대한 정답은 아녀도 해답을 찾아보려고 한다.

## 1. 상속의 한계, 그리고 대안책인 합성

### 1) 상속과 집합의 관계

상속을 공부하다 보면 수학의 **집합**이 생각난다. 좀 생뚱맞은 얘기일 수 있는데 아래의 그림을 보자.

![image](https://github.com/user-attachments/assets/b12f6a2c-9fe4-44bc-8b4f-12e695cd56cc)

집합 A는 집합 B의 부분집합이다. 즉, 집합 B에 속하는 모든 원소들은 곧 집합 A에 속하는 원소라고 봐도 언제나 참이다. 이를 객체의 상속 관계로 옮겨보자.

```java
public class A {
    public String a;

    public void methodOnlyA() {
        System.out.println("집합 A에서만 정의");
    }

    protected void method() {
        a = "집합 A";
        System.out.println(a);
    }
}
```
```java
public class B extends A {
    public String b;

    @Override
    public void method() {
        b = "집합 B";
        System.out.println(b);
    }
}
```

A 객체는 B 객체에 의해 상속되고 있다. 여기서 봐야할 점은 A 객체에만 정의해둔 `methodOnlyA()` 메소드인데, 이 메소드는 분명 B에는 명시되어 있지 않으나, 상속 개념에 의해 B의 인스턴스에서 해당 메소드를 호출할 수 있게 된다. 물론 접근 제한자에 따라서 호출 여부가 달라지겠지만 일단은 집합과의 관계를 위해 모든 필드와 메소드가 `public`이라고 생각해보자.

```java
public class Main {
    public static void main(String[] args) {
        B b = new B();
        b.methodOnlyA(); // 집합 A에서만 정의
        b.method(); // 집합 B
    }
}
```

이를 통해서, 앞으로 A 클래스에서 (접근 제한자가 `public`이라는 가정 하에) 모든 메소드나 필드의 추가는 결국 상속 받는 자식 클래스인 B에서도 똑같이 포함된다. 결국 위의 집합처럼 A가 B의 부분집합 관계임을 알 수 있다. A 집합에 어떤 원소를 계속 추가해도 B 집합에 포함되는 관계가 유지되는 것이다.

### 2) 집합은 자명한 원소 기준이 있으나, 상속은 다차원적이다.

그렇지만 집합과 상속이 완벽히 매칭된다고 할 수는 없다. 집합에는 조건제시법을 통해 명확한 집합의 기준을 정의할 수 있으나 상속 관계의 클래스들은 그렇지 않다. 교재에 꽤나 재밌는 예시가 있어서 이를 확인해보자.

> 우리는 '새'를 추상 클래스로 정의할 것이다. 그리고 클래스 내부에는 '동작'을 의미하는 메소드를 작성해야 될 것이다. 새의 대표적인 동작은 '날기'다. 그래서 `fly()`라는 메소드를 `Brid` 클래스에 넣었다. 이제 준비가 끝났으니 `Bird` 클래스를 만들어서, 세상의 모든 새들을 상속시켜서 클래스로 만들려고 한다.
>
> 그런데 생각해보니 타조나 닭은 날지 못한다. 하지만 얘네들 역시 새에는 포함된다. 그래서 일단은 `Bird` 클래스를 상속받긴 하는데, 날지 못하는 새들이 `fly()` 메소드를 갖고 있다. 이런 모순인 상황을 타개하기 위해 고민해봤지만, 오버라이딩해서 예외를 반환시키는 방법 말고는 적절한 게 보이지 않는다.
>
> 결국 `Bird` 추상 클래스를 상속하는 `FlyableBird` 추상 클래스와 `UnFlyableBird` 추상 클래스를 추가로 정의해서 이제 새들을 클래스로 정의해볼까 한다. 그런데 또 생각해보니 노래를 부를 수 있냐 없냐로도 나뉠 수 있다. 그래서 이번에는 저 날 수 있는 지를 기준으로 나눈 추상 클래스들을 또 상속하는 `FlyableTweetableBird`, `FlyableUnTweetableBird`, `UnFlyableTweetableBird`, `UnFlyableUnTweetableBird` 추상 클래스를 정의했다...

교재에서는 새를 기준으로 클래스 정의를 했을 때, 상속과 관련해서 발생하는 문제점을 명확히 잡아내고 있다. 상속의 본질적인 핵심은 상위 클래스의 **추상적 상태**다. 표현이 추상적 상태라고 되어있지만, 결국 **얼마나 많은 범위를 담아낼 수 있는 기준**이냐를 의미한다. 결국 이 기준을 명확하게 잡지 않고 상위 클래스를 정의해서 상속을 적용하면 위와 같은 딜레마에 빠지게 된다.

위에서 말했던 새 클래스 예시도 결국 **가장 추상적인** 새를 어떻게 정의하냐에서 발생하는 문제라 볼 수 있다. 새라는 생물을 클래스로 표현하기 위해서는, 그리고 그 새들의 구체적인 종류들의 정의해나가기 위해서는 어떻게 초기 기준을 잡냐인데 그것을 **날기**로 잡을지 **노래**로 잡을지에 대한 고민이 위의 예제에서 드러나는 것이다.

이런 문제들에 대한 정답은 잡기가 매우 어렵다. 앞서 말했듯이 집합은 명확한 원소 기준을 제시할 수 있지만, 객체는 현실세계의 기준을 제시하기에는 그 분류 방법이 너무나도 다차원적이기 때문에 상속을 통해 기준을 실현해도 부작용이 발생할 수밖에 없다.

### 3) 상속 대신 합성을 써보자

위에서 말한 새 예제를 클래스로 표현한다면 이렇게 될 것이다.

```java
// 새 추상 클래스
public abstract class Bird {
}

// 날 수 있냐, 없냐
public abstract class FlyableBird extends Bird {
    // 날기 메소드
}

public abstract class UnFlyableBird extends Bird {
}

// 노래할 수 있냐, 없냐
public abstract class FlyableTweetableBird extends FlyableBird {
    // 날기 메소드
    // 노래 메소드
}

public abstract class FlyableUnTweetableBird extends FlyableBird {
    // 날기 메소드
}

public abstract class UnFlyableTweetableBird extends UnFlyableBird {
    // 노래 메소드
}

public abstract class UnFlyableUnTweetableBird extends UnFlyableBird {
}
```

기준이 2개로 늘었을 뿐인데, 추상 클래스가 무려 7개나 된다. 각 추상 클래스에 대응되는 메소드들을 정의하고 하위 클래스에서 맞춰 오버라이딩을 하면서 추후 추가되는 기준에 따라 또 추상 클래스가 늘어나게 되면 단순히 코드 추가에 그치지 않고 상속 계층이 깊어지면서 **코드의 가독성과 유지보수성에 영향**을 끼치게 된다. 또한 전통적인 소프트웨어 아키텍처의 특성인 **캡슐화**를 깨뜨리게 된다. 왜냐하면 부모 클래스에서 정의했던 내용을 하위 클래스에서 다시 재정의하기 위해서는 접근 제한자의 개방이 강제될 수밖에 없기 때문이다.

상속의 본질적인 단점의 원인은, 자식 클래스가 부모 클래스의 모든 것을 가지면서 **동화**되는 것이다. 즉, 부모 클래스에서 `public`하게 정의한 것들은 자식 클래스에서 동일하게 활용이 가능하기 떄문에 **자식 클래스는 곧 부모 클래스와 다를 바가 없어진다**라는 문장이 성립하게 된다. 이 점이 상속의 본질적인 한계이자 단점을 나타낸다. 분명 코드의 재사용성을 증가시키려고 했지만 그만큼 결합이 너무 강력해지는 것이다.

이제 합성을 알아보자. 위에서 언급한 상속의 본질적인 단점인 **결합도가 강해지는 것**을 방지하기 위해서 **부모의 모든 것을 넘기는 상속**에서 **부모의 필요한 동작만을 넘기는 합성**이 대안책으로 제시되는 것이다. 아까 확인한 새 문제는 결국 새의 모든 것을 떠넘기면서 발생하는 문제라고 볼 수 있다. 분류 기준은 **날기** 혹은 **노래** 등에 해당하는 동작에 불과할 뿐인데, 그 동작을 기반으로 분류하기 위해 **새**에 해당하는 모든 것을 넘겨주면서 코드의 가독성과 유지보수성이 떨어지게 되므로 **동작**만을 넘겨주는 방법을 채택하는 것이 합성의 핵심이다.

```java
public interface Flyable {
    // 날기 추상 메소드
}

public interface Tweetable {
    // 노래 추상 메소드
}

public class Oriole implements Flyable, Tweetable {
    // 날기 메소드 구현
    // 노래 메소드 구현
}

public class Eagle implements Flyable {
    // 날기 메소드 구현
}

public class Chicken {
}
```

결국 **합성은 객체의 '무엇이냐'보다는 '무엇을 할 수 있느냐'에 집중**한다. 즉, 객체의 행동(동작)을 조립하듯 구성함으로써 유연하고 유지보수가 쉬운 구조를 만든다.
