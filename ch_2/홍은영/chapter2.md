## 객체지향 프로그래밍
- 코드를 구성하는 기본 단위로 클래스와 객체 사용
- 캡슐화, 추상화, 상속, 다형성 4가지 특성 사용

### 캡슐화
- 데이터를 숨기거나 보호해서 직접적인 접근 제한
- 클래스가 제공하는 메서드를 통해서만 외부 접근을 허가
- `private`, `public` 같은 접근 제어 키워드 사용
- 속성에 대한 직접 접근을 허용하면 무분별한 값 변경 발생 -> 데이터 무결성 훼손 가능
- 필요한 것만 노출하는 제한된 메서드를 제공해 클래스 사용성 향상  
-> 비즈니스 로직을 몰라도 쉽게 사용 가능하고 잘못 사용할 가능성 감소
<br>

### 추상화
- 메서드 내부 구현을 숨기고 기능에만 집중
- 인터페이스나 추상화 클래스에 의존하지 않아도 구현 가능 -> 함수
```java
public interface A {
  void doA();
  int doB();
}

public class B implements A {
  @Override
  public void doA() {}

  @Override
  public int doB() {}
}
```
<br>

### 상속
- is-a 관계, 코드 재사용성 향상
- 자바에서는 `extends` 키워드로 상위 클래스 상속
- 단일 상속 : 하위 클래스가 하나의 상위 클래스만 상속하는 것
- 다중 상속 : 하위 클래스가 여러 개의 상위 클래스를 동시에 상속하는 것  
-> 자바는 단일 상속만 지원
- 상속 계층이 깊고 복잡하면 코드 가독성과 유지 관리성 떨어짐 -> 안티 패턴 가능성
<br>

### 다형성
- 하위 클래스를 상위 클래스 대신 사용하고 하위 클래스 메서드를 호출할 수 있는 특성
- 상속과 메서드 재정의 방식
  - 상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의
```java
class A {
    void add() {A 동작}
}
class B extends A {
    @Override
    void add() {B 동작}
}

A a = new B(); // 다형성
a.add();  // B 동작
```

- 인터페이스 방식 : 대충 추상화 코드랑 비슷

- Duck-Typing 방식
  - 두 클래스가 동일한 메서드를 가지고 있으면 명시적인 관계없이 다형성 성립
```python
class A:
  def record(): ~~

class B:
  def record(): ~~

a = A()
b = B()

a.record() # A 동작
b.record() # B 동작
```
<br><br>

## 절차적 프로그래밍
- 함수나 메서드로 구성되며 순차적으로 실행되는 명령어 집합
- 데이터는 함수나 메서드와 분리되어 관리되며 함수 내에서 조작 및 처리
- 데이터와 기능을 하나로 묶지 않고 기능을 독립적으로 구현하여 순차적으로 처리

### 절차적과 비교한 객체지향의 장점
1. 대규모의 복잡한 프로그램 개발에 적합
2. 재사용, 확장, 유지 관리가 쉽다
3. 사용자 친화적이고 고급언어이며 지능적
<br>

### 객체지향처럼 보이는 절차적 코드
#### 1. getter, setter 메서드 남용
- 캡슐화는 내부 데이터를 감추고 클래스에서 제공하는 메서드로만 외부에서 간접 접근하는 것
- private으로 정의한 속성을 public한 setter로 노출하는 것은 캡슐화에 위배
- getter로 반환받은 컬렉션을 외부에서 수정하면 다른 속성과의 무결성이 깨질 수 있음

✅ 개선 방향  
- Collections.unmodifiableList() 메서드로 컬렉션 데이터가 수정되는 것 방지
- 필요할 경우에만 setter 사용
<br>

#### 2. 전역 변수와 전역 메서드 남용
- 클래스가 자신이 사용할 상수를 내부에 직접 정의하면 응집력 및 재사용성 향상

✅ 개선 방향  
- Constants, Utils 같은 공통 클래스는 기능에 따라 분리
- 상수는 관련 클래스 내부에서 관리해 책임과 역할 명확히 하기
<br>

#### 3. 데이터와 메서드 분리로 클래스 정의하기
- 대표적으로 MVC 패턴  
-> Controller, Service, Repository에서는 로직, VO, BO, Entity는 데이터 담당
<br><br><br>

## 함수형 프로그래밍
- 코드 구성 단위는 상태 없는 함수  
->함수 내부 변수는 지역 변수로 입력 매개변수에만 영향받음

### Stream
- `.` 연산자로 여러 함수의 연산을 계단식으로 작성
- 중간 작업은 stream 클래스 객체를 반환하고, 종료 작업은 최종 결과를 반환해 스트림 종료

### 람다 표현식
- 함수를 간결하게 표현할 수 있는 문법
- 기본 구조는 입력, 함수 본문, 출력이지만 유연하게 변형 가능

### 함수형 인터페이스
- 자바는 함수형 인터페이스를 변수처럼 사용 -> C언어 함수 포인터와 비슷
- 추상 메서드가 하나만 존재 -> 람다가 대응하는 인터페이스를 명확히 알 수 있음
<br><br><br>

## 사용자 인증 방식
### 1. 기본 인증(Basic Authentication)
- 헤더에 {아이디:비밀번호}를 Base64로 인코딩해 전송하는 방식
- Base64는 단순한 인코딩 방식으로 비밀번호가 노출될 위험이 있고 보안에 취약
- HTTPS와 같이 사용해야 안전
- 매 요청마다 인증 정보를 포함해야 해서 효율성이 낮고 리플레이 공격에 취약
<br>

### 2. 토큰 기반 인증(Token-Based Authentication)
- 사용자 정보를 암호화해 생성한 토큰을 사용한 인증 방식
- 비밀번호를 매번 전송할 필요 없이 안전하게 인증 가능
- 공격자가 정보를 가로채고 동일한 토큰을 전송해 인증을 우회할 위험 존재
- 토큰 자체를 탈취당하면 만료 전까지 악용 가능
<br>

### 3. 토큰 인증 보안 강화 -> 랜덤 변수 사용
- 유효시간 내에서만 토큰이 유효하도록 시간값을 추가해 토큰을 매번 다르게 생성해서 보안 강화
- 서버는 요청받은 토큰의 유효시간이 초과하면 만료된 것으로 간주하고 요청 거부
<br>

### 4. OAuth 2.0, JWT
- OAuth 2.0 : 제3자가 사용자 인증 대리 수행 -> 카카오 로그인, 구글 로그인
- JWT (JSON Web Token) : JSON 형식으로 토큰을 인코딩해 서명된 토큰으로 안전하게 인증하는 방식
- JWT는 iat(issued at, 발급 시간)와 exp(expiration, 만료 시간) 필드로 토큰 유효성 검증