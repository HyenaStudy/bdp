> 생성 패턴  
> 객체 생성 문제를 해결하고 복잡한 생성 프로세스를 캡슐화하며 객체의 생성 코드와 사용 코드 분리하는 패턴
<br>

# 싱글턴 패턴
- 클래스의 객체나 인스턴스를 하나만 생성
- new 키워드 없이 바로 사용할 수 있어서 편리
- ex) 시스템 설정 정보 관리, 고유 ID 생성
- 가급적 사용 X  
  → but, 클래스 확장가능성이 없고 외부 시스템에 의존하지 않으면 싱글턴이 합리적

## 구현
**싱글턴 구현 조건**
1. 생성자를 private로 선언해 외부에서 new를 이용한 인스턴스 생성 방지
2. 객체 생성될 때 스레드 안전성 보장 확인
3. 지연 로딩 지원여부 확인
4. getInstance() 성능 검토
<br>

### 1. 즉시 초기화
- 클래스가 메모리에 적재될 때 인스턴스 생성
- 지연 적재 미지원
- 사용하지 않아도 인스턴스를 만들어 메모리 낭비 발생

### 2. 늦은 초기화
- getInstance() 호출할 때 인스턴스 생성
- 지연 적재 지원
- 초기화 시간이 오래 걸리면 시스템 성능에 영향 → 즉시 초기화 방식으로 해결 가능
- 동시성이 낮아 병목 현상 발생 가능
<br>

> PermGen Space OOM(Out Of Memory)
> - Tomcat에서 가용할 수 있는 최대 메모리보다 어플리케이션을 구동하는데 필요한 메모리가 더 커서 발생하는 문제
> - JDK 8 이상부턴 PermGen 영역 정보를 Metaspace로 이동하면서 PermGen 제거함
> - 디폴트 값이 작아서 PermGen Space OOM 에러 발생하면 maxpermsize 값 증가
> - 상세 내용은 https://buly.kr/1uH2KR 참고
<br>

### 3. 이중 잠금
- 지연 적재와 높은 동시성을 모두 지원
- 인스턴스 생성 후 getInstance()를 계속 호출해도 잠금 미발생 → 낮은 동시성 해결

### 4. 홀더에 의한 초기화
- 정적 내부 클래스를 사용하는 방식
- 스레드 안정성 보장, 지연 로딩 가능

### 5. 열거
- 열거형 특성을 활용해서 스레드 안전성과 인스턴스 유일성 보장
<br>

## 단점
1. 클래스 간의 의존성 감춤
2. 확장성이 낮고 테스트 어려움
4. 매개변수가 있는 생성자 지원 X → 매개변수를 통해 크기 지정 불가  
  **해결방법**
    1) init()로 매개변수 전달
    2) 매개변수를 getInstance()에 전달
      - 첫번째 이후 getInstance는 효과 없음
    3) 매개변수를 전역 변수에 넣기
<br>

## 대안
- 정적 메서드 사용  
  → 테스트 용이성과 확장성 문제 해결 불가
- 의존성 주입
  - 싱글턴으로 생성된 객체를 매개변수로 함수에 전달
  - 생성자를 통해 클래스의 멤버 변수에 전달  
  → 마찬가지로 테스트 용이성과 확장성 문제 해결 불가
<br>

## 다중 인스턴스 패턴
- 클래스가 여러 객체를 생성할 수 있지만 갯수 제한
- 동일한 유형 객체는 하나만 생성 가능, 다른 유형은 여러 개 생성 가능
- 팩토리 패턴과 유사
<br>

> enum
> - 리팩터링할 때 enum 부분만 수정하면 됨
> - 스레드안전해서 싱글톤 패턴 만들 때 유용
> → https://youtu.be/3rfbnQYOCFA?si=RYnyg_9mIJ_hedge 강의 참고
<br><br><br>

# 팩토리 패턴
- 객체 생성 로직을 캡슐화해 추상화한 패턴
- 생성과 사용을 분리해 코드 복잡성 감소, 유지보수성 증가, 결합도 감소
- 상위 클래스는 구조를 정의하고 하위 클래스에서 객체 생성
<br>

**팩토리 패턴을 사용하는 경우**
1. 객체 생성이 반복될 때
2. 객체 생성 과정이 복잡할 때
→ 생성 과정이 간단하면 단순 팩토리, 복잡하면 팩토리 메서드, 규모가 크면 추상 팩토리 사용
<br>

## 단순 팩토리 패턴
- 여러 객체 생성 로직을 하나의 팩토리 클래스에 넣는 것
- 클라이언트는 타입만 넘기고 팩토리에서 객체 생성해 반환
- 조건문을 사용해 인스턴스를 분기 생성
- ex) 자바 DateFormat, Calendar 클래스
<br>

## 팩토리 메서드 패턴
- 객체 생성 책임을 서브클래스로 분리
- 조건문 대신 다형성을 사용해서 개방 폐쇄 원칙(OCP) 만족
<br>

## 추상 팩토리 패턴
- 복잡해서 잘 사용 X
- 팩토리 클래스가 너무 많아져 시스템을 유지하기 어려울 때 사용
<br>

**팩토리 메서드 패턴 vs 추상 팩토리 패턴**
| 구분             | 팩토리 메서드 패턴                     | 추상 팩토리 패턴                        |
| ---------------- | ------------------------------------- | -------------------------------------- |
| 목적             | 객체 생성 책임을 서브클래스로 분리    | 관련된 객체들을 한꺼번에 생성           |
| 구현 방식        | 상속과 오버라이딩으로 객체 생성        | 인터페이스와 구성(composition)으로 생성 |
| 사용 시점        | 한 종류 객체를 여러 방식으로 생성     | 여러 객체를 함께 생성해야 할 때         |
| 확장성           | 서브클래스만 추가하면 됨              | 인터페이스 변경 시 모든 서브클래스 수정 필요 |
| 클라이언트와의 관계 | 서브클래스로 구체 클래스 분리         | 관련 객체를 묶어 일관되게 사용 가능      |
<br><br><br>

# 빌더 패턴
- 복합 객체의 생성 과정을 캡슐화해 생성 단계를 분리
- 내부 구조를 클라이언트에서 보호/숨김
- 여러 단계를 거쳐 객체를 생성 → 팩토리 패턴은 한 단계에서 모두 처리
<br><br><br>

# 프로토타입 패턴
- 기존 인스턴스를 복사해서 새로운 인스턴스 생성
- 객체 생성 비용이 많거나 복잡할 때 사용
- 자바에서는 clone() 메서드나 역질렬화 이용해서 구현
- 클라이언트가 구체적인 것을 전혀 몰라도 새 인스턴스 생성 가능