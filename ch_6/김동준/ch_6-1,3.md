# 싱글톤 패턴

## 1. 구현 방식
### 1) 즉시 초기화 vs 지연 초기화
- 별다른 구현 제약 없이 기본 생성자를 `private`로 막는다는 점과 `static` 필드로 인스턴스를 담을 변수를 정의한다는 점은 같음
- **대신, 인스턴스 생성이 클래스가 로딩될 때 같이 이뤄지는지(즉시 초기화), 사용될 때 그제야 생성되는지(지연 초기화)에서 차이가 있음**
- 둘 중 어떤 것이 더 낫다는 건 없다. 만약 인스턴스 생성 과정이 복잡하고 시간이 오래 걸린다면, 미리 프로그램을 실행할 때에 초기화 작업을 수행하는 즉시 초기화가 더 유리할 수 있다.
### 2) 지연 초기화 vs 이중 잠금
- 지연 초기화로 생성된 싱글톤 클래스의 `getInstance()` 메소드에 스레드 안전을 위하여 잠금(`synchornized`)을 거는 경우가 많다. 이는 멀티 스레드에서 잦은 잠금으로 병목 현상이 발생할 수 있어서 **이중 잠금**이 대안책으로 제시된다.
```java
public class IdGenerator {
  private AtomicLong id = new AtomicLong(0);
  private static volatile IdGenerator instance;

  private IdGenerator() {}

  public static IdGenerator getInstance() {
    if (instance == null) {
      synchronized(IdGenerator.class) { // 클래스 레벨에서 잠금 처리
        if (instance == null) instance = new IdGenerator();
      }
    }
    return instance;
  }

  public long getId() {
    return id.incrementAndGet();
  }
}
```
- 처음 인스턴스를 생성하기 위해 `getInstance()`에 접근할 때는, 외부 if문의 블록에 진입하면서 `synchronized` 블록을 마주하게 된다. 이 과정에서 잠금이 걸리며 스레드 안전을 챙기면서 인스턴스가 생성돼서 반환된다. 그리고 추후 다시 `getInstance()`가 호출될 때는 바로 인스턴스가 반환되고 별도의 잠금 처리가 없어서 메소드 레벨에서 잠금이 걸리는 지연 초기화에 비해 성능 최적화가 가능하다.
- 객체 생성 과정은 **(1) 메모리 공간 확보**, **(2) 생성자 실행**, **(3) 참조 변수에 주소 할당**(`instance = new IdGenerator()`) 순서로 이뤄지는데 JVM이나 CPU가 최적화를 위해 2번과 3번 순서를 바꾸는 상황이 있을 수도 있다.
>- 만약 정적 변수에 `volatile` 키워드가 없는 상황에서 스레드 A가 객체 초기화 과정에서 스레드 B가 동시에 접근하는 경우를 가정하자.
>- B의 입장에서 처음 if문이 `true`여서 `synchronized` 블록에 진입하게 된다.
>- JVM이 만약 3번 과정을 2번과 바꾼다면 인스턴스가 없지만 참조 변수에 주소가 할당돼서 B는 내부 if문 조건이 `false`가 돼서 그대로 벗어난다.
>- 그래서 곧바로 `instance` 변수가 반환된다. 즉, 생성되지 않은 **좀비 객체**가 반환돼서 부작용이 발생할 수 있다.
- 그래서 정적 변수에 `volatile` 키워드를 붙여서 가시성을 확보해야 한다. 객체 초기화가 끝나기 전까진 다른 스레드에서 해당 변수를 볼 수 없으면서 모든 스레드가 최신 상태의 변수를 공유하게 된다.

### 3) 홀더 구현
- 홀더는 **내부 정적 클래스**를 의미한다.
```java
public class IdGenerator {
  private AtmoicLong id = new AtomicLong(0);

  private IdGenerator() {}

  private static class Holder {
    private static final IdGenerator INSTANCE = new IdGenerator();
  }

  public static IdGenerator getInstance() {
    return Holder.INSTANCE;
  }

  public long getId() {
    return id.incrementAndGet();
  }
}
```
- 자바의 클래스 로딩 원칙은, **외부 클래스가 로딩돼도, 내부 클래스는 사용될 때까지 로딩되지 않는다.** 즉, 지연 초기화처럼 `Holder` 정적 클래스는 사용되기 전까지 로딩되지 않는 것이다. **JVM의 클래스 초기화 과정은 스레드 안전하게 수행되며(동시성 이슈 극복) 내부적으로 메모리 배리어를 갖춘 데다가(가시성 확보) 로딩 매커니즘상 사용 전까지 내부 클래스는 로딩되지 않는다.(지연 초기화)**
- 요약하자면 모든 이슈를 JVM의 클래스 로딩 매커니즘으로 전부 극복할 수 있다.
### 4) 열거 구현
- `enum`은 JVM에서 조금 특별하게 취급된다. 변수를 보유한 `enum` 객체(java)를 컴파일한 바이트코드(class)를 JVM 명령어 수준으로 조회하면 다음처럼 나온다.
```java
public enum Singleton {
  INSTANCE;
}
```
<img width="70%" alt="스크린샷 2025-05-16 오전 1 08 30" src="https://github.com/user-attachments/assets/ff38d74d-e30d-47f5-96f5-63f9f260b701" />

- `INSTANCE`는 `enum` 타입의 "정적 상수(`static final` 필드)"인데, 마치 싱글톤 인스턴스처럼 취급된다. 그래서 클래스 로딩 시점에 한 번만 초기화된다.
- `values()` 메소드는 `enum`의 모든 상수들을 배열로 만든 후, 원본 배열을 복사해서 반환하다. 그래서 원본 배열을 직접 건드릴 수 없기 때문에 **스레드 안전성**이 보장된다.
- `static` 정적 블록 내에서 `INSTANCE` 객체를 딱 한 번 생성되는데, **JVM이 이 시점에 유일 인스턴스를 변수에 할당한다.**
- 또한, `enum` 생성자는 상속도 불가능하고 직접 코드에 명시되지 않아서 리플렉션 활용도 불가능하다.
