# 싱글톤 패턴

## 1. 구현 방식
### 1) 즉시 초기화 vs 지연 초기화
- 별다른 구현 제약 없이 기본 생성자를 `private`로 막는다는 점과 `static` 필드로 인스턴스를 담을 변수를 정의한다는 점은 같음
- **대신, 인스턴스 생성이 클래스가 로딩될 때 같이 이뤄지는지(즉시 초기화), 사용될 때 그제야 생성되는지(지연 초기화)에서 차이가 있음**
- 둘 중 어떤 것이 더 낫다는 건 없다. 만약 인스턴스 생성 과정이 복잡하고 시간이 오래 걸린다면, 미리 프로그램을 실행할 때에 초기화 작업을 수행하는 즉시 초기화가 더 유리할 수 있다.
### 2) 지연 초기화 vs 이중 잠금
- 지연 초기화로 생성된 싱글톤 클래스의 `getInstance()` 메소드에 스레드 안전을 위하여 잠금(`synchornized`)을 거는 경우가 많다. 이는 멀티 스레드에서 잦은 잠금으로 병목 현상이 발생할 수 있어서 **이중 잠금**이 대안책으로 제시된다.
```java
public class IdGenerator {
  private AtomicLong id = new AtomicLong(0);
  private static volatile IdGenerator instance;

  private IdGenerator() {}

  public static IdGenerator getInstance() {
    if (instance == null) {
      synchronized(IdGenerator.class) { // 클래스 레벨에서 잠금 처리
        if (instance == null) instance = new IdGenerator();
      }
    }
    return instance;
  }

  public long getId() {
    return id.incrementAndGet();
  }
}
```
- 처음 인스턴스를 생성하기 위해 `getInstance()`에 접근할 때는, 외부 if문의 블록에 진입하면서 `synchronized` 블록을 마주하게 된다. 이 과정에서 잠금이 걸리며 스레드 안전을 챙기면서 인스턴스가 생성돼서 반환된다. 그리고 추후 다시 `getInstance()`가 호출될 때는 바로 인스턴스가 반환되고 별도의 잠금 처리가 없어서 메소드 레벨에서 잠금이 걸리는 지연 초기화에 비해 성능 최적화가 가능하다.
- 객체 생성 과정은 **1.메모리 공간 확보**, **2.생성자 실행**, **3.참조 변수에 주소 할당**(`instance = new IdGenerator()`) 순서로 이뤄지는데 JVM이나 CPU가 최적화를 위해 2번과 3번 순서를 바꿀 수도 있다.

- 지연 초기화
- 이중 잠금
- 홀더에 의한 초기화
- 열거
