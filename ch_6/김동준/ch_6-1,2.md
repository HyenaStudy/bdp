# 싱글톤 패턴

## 1. 구현 방식
### 1) 즉시 초기화 vs 지연 초기화
- 별다른 구현 제약 없이 기본 생성자를 `private`로 막는다는 점과 `static` 필드로 인스턴스를 담을 변수를 정의한다는 점은 같음
- **대신, 인스턴스 생성이 클래스가 로딩될 때 같이 이뤄지는지(즉시 초기화), 사용될 때 그제야 생성되는지(지연 초기화)에서 차이가 있음**
- 둘 중 어떤 것이 더 낫다는 건 없다. 만약 인스턴스 생성 과정이 복잡하고 시간이 오래 걸린다면, 미리 프로그램을 실행할 때에 초기화 작업을 수행하는 즉시 초기화가 더 유리할 수 있다.
### 2) 지연 초기화 vs 이중 잠금
- 지연 초기화로 생성된 싱글톤 클래스의 `getInstance()` 메소드에 스레드 안전을 위하여 잠금(`synchornized`)을 거는 경우가 많다. 이는 멀티 스레드에서 잦은 잠금으로 병목 현상이 발생할 수 있어서 **이중 잠금**이 대안책으로 제시된다.
```java
public class IdGenerator {
  private AtomicLong id = new AtomicLong(0);
  private static volatile IdGenerator instance;

  private IdGenerator() {}

  public static IdGenerator getInstance() {
    if (instance == null) {
      synchronized(IdGenerator.class) { // 클래스 레벨에서 잠금 처리
        if (instance == null) instance = new IdGenerator();
      }
    }
    return instance;
  }

  public long getId() {
    return id.incrementAndGet();
  }
}
```
- 처음 인스턴스를 생성하기 위해 `getInstance()`에 접근할 때는, 외부 if문의 블록에 진입하면서 `synchronized` 블록을 마주하게 된다. 이 과정에서 잠금이 걸리며 스레드 안전을 챙기면서 인스턴스가 생성돼서 반환된다. 그리고 추후 다시 `getInstance()`가 호출될 때는 바로 인스턴스가 반환되고 별도의 잠금 처리가 없어서 메소드 레벨에서 잠금이 걸리는 지연 초기화에 비해 성능 최적화가 가능하다.
- 객체 생성 과정은 **(1) 메모리 공간 확보**, **(2) 생성자 실행**, **(3) 참조 변수에 주소 할당**(`instance = new IdGenerator()`) 순서로 이뤄지는데 JVM이나 CPU가 최적화를 위해 2번과 3번 순서를 바꾸는 상황이 있을 수도 있다.
>- 만약 정적 변수에 `volatile` 키워드가 없는 상황에서 스레드 A가 객체 초기화 과정에서 스레드 B가 동시에 접근하는 경우를 가정하자.
>- B의 입장에서 처음 if문이 `true`여서 `synchronized` 블록에 진입하게 된다.
>- JVM이 만약 3번 과정을 2번과 바꾼다면 인스턴스가 없지만 참조 변수에 주소가 할당돼서 B는 내부 if문 조건이 `false`가 돼서 그대로 벗어난다.
>- 그래서 곧바로 `instance` 변수가 반환된다. 즉, 생성되지 않은 **좀비 객체**가 반환돼서 부작용이 발생할 수 있다.
- 그래서 정적 변수에 `volatile` 키워드를 붙여서 가시성을 확보해야 한다. 객체 초기화가 끝나기 전까진 다른 스레드에서 해당 변수를 볼 수 없으면서 모든 스레드가 최신 상태의 변수를 공유하게 된다.

### 3) 홀더 구현
- 홀더는 **내부 정적 클래스**를 의미한다.
```java
public class IdGenerator {
  private AtmoicLong id = new AtomicLong(0);

  private IdGenerator() {}

  private static class Holder {
    private static final IdGenerator INSTANCE = new IdGenerator();
  }

  public static IdGenerator getInstance() {
    return Holder.INSTANCE;
  }

  public long getId() {
    return id.incrementAndGet();
  }
}
```
- 자바의 클래스 로딩 원칙은, **외부 클래스가 로딩돼도, 내부 클래스는 사용될 때까지 로딩되지 않는다.** 즉, 지연 초기화처럼 `Holder` 정적 클래스는 사용되기 전까지 로딩되지 않는 것이다. **JVM의 클래스 초기화 과정은 스레드 안전하게 수행되며(동시성 이슈 극복) 내부적으로 메모리 배리어를 갖춘 데다가(가시성 확보) 로딩 매커니즘상 사용 전까지 내부 클래스는 로딩되지 않는다.(지연 초기화)**
- 요약하자면 모든 이슈를 JVM의 클래스 로딩 매커니즘으로 전부 극복할 수 있다.
### 4) 열거 구현
- `enum`은 JVM에서 조금 특별하게 취급된다. 변수를 보유한 `enum` 객체(java)를 컴파일한 바이트코드(class)를 JVM 명령어 수준으로 조회하면 다음처럼 나온다.
```java
public enum Singleton {
  INSTANCE;
}
```
<img width="70%" alt="스크린샷 2025-05-16 오전 1 08 30" src="https://github.com/user-attachments/assets/ff38d74d-e30d-47f5-96f5-63f9f260b701" />

- `INSTANCE`는 `enum` 타입의 "정적 상수(`static final` 필드)"인데, 마치 싱글톤 인스턴스처럼 취급된다. 그래서 클래스 로딩 시점에 한 번만 초기화된다.
- `values()` 메소드는 `enum`의 모든 상수들을 배열로 만든 후, 원본 배열을 복사해서 반환하다. 그래서 원본 배열을 직접 건드릴 수 없기 때문에 **스레드 안전성**이 보장된다.
- `static` 정적 블록 내에서 `INSTANCE` 객체를 딱 한 번 생성되는데, **JVM이 이 시점에 유일 인스턴스를 변수에 할당한다.**
- 또한, `enum` 생성자는 상속도 불가능하고 직접 코드에 명시되지 않아서 리플렉션 활용도 불가능하다.

## 2. 싱글톤의 단점
- 생성자가 직접 드러나지 않고 매개변수 전달 케이스가 적어서 의존성 확인이 매우 어렵다.
- 싱글톤 특성상 유일 인스턴스를 전제로 하기 때문에 향후에 복수의 인스턴스가 필요한 상황에서의 수정이 매우 복잡해진다.
- 테스트를 위한 모킹 처리가 매우 어렵고, 매개변수 포함 생성자를 지원하지 않아서 매개변수가 요구되는 초기화가 불가능하다. 만약 매개변수 포함 싱글톤 클래스를 생성하려면 별개의 클래스에 정적 파라미터를 두고 참조해오는 방식을 생각해볼 수 있다.

## 4. 멀티 스레드, 멀티 프로세스, 스프링 IoC 컨테이너 내에서의 싱글톤
- 위에서 본 다양한 싱글톤 생성 방식에서 `static` 필드(혹은 내부 클래스)는 정적이라서 JVM에 한번 로딩될 때만 초기화되고, 그 이후에(뭔가 극미세한 오차로 다른 스레드가 올려져도) 이미 정적 관련된 내용은 로딩돼서 초기화됐기 때문에 다른 스레드에선 별도로 초기화되지 않는다. 그래서 단일 프로세스의 멀티 스레드여도 유일한 인스턴스가 보장된다.
- 멀티 프로세스, 즉 클러스터 환경에서는 JVM의 범위를 넘어서는 싱글톤은 외부 분산 락 등이 요구된다.
- 스프링 IoC 컨테이너 내부에서의 빈 역시 싱글톤으로 관리되는데 이는 자바 언어 레벨의 싱글톤 인스턴스가 아닌, 컨테이너 내의 ‘빈 이름’을 기준으로 한 **컨테이너 범위의 싱글톤 인스턴스**다. 그래서 하나의 JVM 내에서 `ApplicationContext` 인터페이스를 다양하게 구현하면 그만큼 컨테이너 개수가 늘어나므로 단일 JVM 내에서 복수의 인스턴스를 가지게 된다.

## 5. 생각해보기
### 1) 268p 생각해보기
- 해당 싱글톤 인스턴스 호출 메소드를 직접 명시적으로 메소드 내부에서 호출하지 않고 파라미터로 전달받는다.
### 2) 273p 생각해보기
- 클래스가 로딩되는 시점에 정적 필드 역시 초기화가 이뤄지고, 보통 싱글톤 인스턴스는 이때 초기화가 이뤄지는 게 가장 빠르다(즉시 초기화).
- 이 역할을 클래스 로더가 맡는데, JVM 내에는 클래스 로더가 여러 개일 수도 있다(부트스트랩 클래스 로더, 확장 클래스 로더, 애플리케이션 클래스 로더 등등...).
- 클래스 네임스페이스는 **클래스 로더 + 클래스 이름** 조합으로 구성돼서 하나의 클래스 로더 내에서는 싱글톤의 유일성이 지켜지나, 복수의 클래스 로더들 간에서는 싱글톤의 유일성이 지켜지지 않을 수 있다.
- 그래서 단일 JVM보다 더 좁은 범위인 단일 클래스 로더에서 싱글톤 유일성이 지켜진다는 한계를 갖게 된다.
