# 팩토리 메소드

## 1. 팩토리 패턴의 등장 배경

- 객체의 생성 단계에 **복잡한 절차**가 포함된다.
- 객체의 생성과 사용이 결합돼서 **만약 객체 생성 로직이 수정되면 사용 로직도 영향을 받는다.**

이 2개를 해결하기 위해 생성 로직을 하위에 위임시키고 생성 책임을 하나로 묶는다.

## 2. 탐구

### 1) 패턴 청사진

**(1) 공통 기능으로 묶을 수 있는 객체들이 있으면 묶어버린다.**

```java
class A, B implements Common:
    @Override
    void method();
```

**(2) 객체 생성 책임을 크리에이터의 추상 메소드에게 넘기고, 원하는 객체에 대응되는 크리에이터 구현체를 만든다.**
```java
abstract class Creator:
    // 객체별 상응되는 하위 구현체에서 실제 생성을 맡는다.
    abstract Common create(); // 팩토리 메소드!

    // 크리에이터는 생성 책임이 주체가 아님
    // 크리에이터를 통해 공통 로직의 실행까지 같이 책임을 진다.
    void process():
        Common object = create();
        object.method(); // 프로세스!

class ACreator, BCreator extends Creator:
    @Override
    Common create():
        return new A() or new B();
```
핵심은, 크리에이터 클래스는 생성을 하위에 던지고 공통 기능의 프로세스를 처리하면서 생성과 사용을 분리한다.

### 2) 크리에이터를 추상 클래스와 인터페이스 둘 중 무엇을 선택해서 구축할까
- 보통은 인터페이스, 크리에이터가 외부 설정 등에 의존해야 하면 의존성 주입이 필요하니까 이럴 경우에는 추상 클래스가 맞을듯

# 추상 팩토리

