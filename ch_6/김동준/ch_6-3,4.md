# 팩토리 메소드

## 1. 팩토리 패턴의 등장 배경

- 객체의 생성 단계에 **복잡한 절차**가 포함된다.
- 객체의 생성과 사용이 결합돼서 **만약 객체 생성 로직이 수정되면 사용 로직도 영향을 받는다.**

이 2개를 해결하기 위해 생성 로직을 하위에 위임시키고 생성 책임을 하나로 묶는다.

## 2. 탐구

### 1) 패턴 청사진

**(1) 공통 기능으로 묶을 수 있는 객체들이 있으면 묶어버린다.**

```java
class A, B implements Common:
    @Override
    void method();
```

**(2) 객체 생성 책임을 크리에이터의 추상 메소드에게 넘기고, 원하는 객체에 대응되는 크리에이터 구현체를 만든다.**
```java
abstract class Creator:
    // 객체별 상응되는 하위 구현체에서 실제 생성을 맡는다.
    abstract Common create(); // 팩토리 메소드!

    // 크리에이터는 생성 책임이 주체가 아님
    // 크리에이터를 통해 공통 로직의 실행까지 같이 책임을 진다.
    void process():
        Common object = create();
        object.method(); // 프로세스!

class ACreator, BCreator extends Creator:
    @Override
    Common create():
        return new A() or new B();
```
핵심은, 크리에이터 클래스는 생성을 하위에 던지고 공통 기능의 프로세스를 처리하면서 생성과 사용을 분리한다.

### 2) 크리에이터를 추상 클래스와 인터페이스 둘 중 무엇을 선택해서 구축할까
- 보통은 인터페이스, 크리에이터가 외부 설정 등에 의존해야 하면 의존성 주입이 필요하니까 이럴 경우에는 추상 클래스가 맞을듯

# 추상 팩토리

## 1. 팩토리 메소드와의 차이

- 관련 있는 객체들을 일관된 방식으로 생성해야 할 때가 있다.
- **서로 다른 객체들이지만 같은 제품군(같은 테마/스타일)** 에 속하기 때문에, 묶어서 관리하고 생성하고 싶다.
- 제품들을 개별적으로 생성하면 서로 호환되지 않거나 스타일이 섞일 수 있는 위험이 있다

**팩토리 메소드**를 통해 단일 객체에 대한 생성과 사용을 분리하는데, 이 객체 외에도 또 다른 객체들의 생성 과정을 테마 단위로 묶을 수 있다면 그 팩토리 메소드를 추상화하는 것이 **추상 팩토리**

## 2. 탐구

### 1) 패턴 청사진

**(1) 관련 있는 제품들이 하나로 묶인다.**
```java
class AChair, BChair implements Chair:
    @Override
    void sit();

class ADesk, BDesk implements Desk:
    @Override
    void work();
```

**(2) 추상 팩토리 메소드를 구축한다. 객체의 세트 단위로 묶는 느낌
```java
interface Factory:
    // 생성을 추상화한 팩토리 메소드들
    Chair createChair();
    Desk createDesk();

    // 사용을 처리하는 메소드
    default void useChairAndDesk():
        Chair chair = createChair();
        Desk desk = createDesk();

        chair.sit();
        desk.work();

// 만약 A 테마의 제품군들을 구현한다면
class AFactory implements Factory:
    @Override
    Chair createChair():
        return new AChair();

    @Override
    Desk createDesk():
        return new ADesk();
```
단순 팩토리 메소드에서 좀 더 큰 분류 범위로 객체들을 정리해서 한 번에 사용 단위를 묶을 수 있을 때, 활용하기 좋음
