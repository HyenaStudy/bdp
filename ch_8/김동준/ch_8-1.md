# 옵저버 패턴

## 1. 동기적 옵저버 패턴

```java
// 발행자
public class PublisherImpl implements Publisher {

    private final Service service; // 발행 서비스 의존성 주입
    private final List<Subscriber> subscribers = new ArrayList<>(); // 구독자 관리

    public PublisherImpl(Service service) {
        this.service = service;
    }

    // 구독자 추가
    public void addSubscribers(List<Subscriber> addedSubscribers) {
        this.subscribers.addAll(addedSubscribers);
    }

    // 발행 - 구독 전파
    public void publish(Parameter parameter) {
        ServiceResult result = service.doService(parameter);

        // 동기적인 이벤트 전파
        for (Subscriber subcriber: subscribers) {
            subscriber.subscribe(result);
        }
    }
}
```
- 해당 구조는 가장 원시적인 옵저버 패턴 구현 모식이다
- 동기적 구조의 문제점은 **구독자의 구독 결과 수신이 공정하지 않은 것**과 **발행자에게 전부 위임되는 책임**이다
- 그래서 비동기 구조 도입이 자연스럽고, 이로 인해 고전적인 디자인 패턴에서 가장 이질적인 패턴이라고 생각함

## 2. 비동기 + 논블로킹으로의 확장

```java
// 이벤트 발행체
@Component
@RequiredArgsConstructor
public class TransactionalKoreanEventPublisherAdapter implements KoreanEventPublisher {

    private final ApplicationEventPublisher eventPublisher;

    @Override
    public void publishCreateEvent(Long id, KoreanCreateDTO dto) {
        eventPublisher.publishEvent(new CreateEvent(id, dto));
    }

    // ...
```
```java
// 이벤트 구독체
@Slf4j
@Component
@RequiredArgsConstructor
public class TransactionalKoreanEventListener implements KoreanEventListener {

    private final ElasticsearchClient elasticsearchClient;

    @Override
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void listenCreateEvent(CreateEvent event) throws IOException {
        log.info("생성 이벤트 발생, {}", event.getId());
        elasticsearchClient.index(i -> i.index("koreans")
                .id(String.valueOf(event.getId()))
                .document(event.getDto()));
    }

    // ...
```
*출처 : [내 레포](https://github.com/kimD0ngjun/search/blob/main/search_sol/src/main/java/com/example/search_sol/infrastructure/listener/TransactionalKoreanEventListener.java)*

- 기존의 동기적 옵저버 패턴에서 보완 + 확장된 구조가 Pub/Sub 모델이다
- 위의 예시에서 발행자(Publisher)는 `KoreanEventPublisher`, 구독자(Subscriber)는 `KoreanEventListener`이다
- 또한, 실제 구독 처리 로직은 `ApplicationEventPublisher`의 기본 구현체가 맡는다. 즉, 이벤트 전달 중재자(Subscription)가 된다
- 이를 통해 발행자와 구독자를 분리하면서 구독자들을 멀티 스레드로 할당하는 비동기 논블로킹 이벤트 전파가 가능해진다
- 그럼에도 이벤트 전파의 책임이 발행자에게 위임됐다는 단점은 아직 해소되지 않았다

## 3. 리액티브 프로그래밍 - 발행자 중심에서 협상 중심으로

| 개념                       | 설명                                             |
| ------------------------ | ---------------------------------------------- |
| **Publisher**            | 데이터를 발행하되, 구독자 요청량 만큼만 전달 (push + pull 혼합)   |
| **Subscriber**           | 수신자이며 `onNext`, `onError`, `onComplete`로 응답하되, `request(n)`을 통해 요청량을 직접 명시    |
| **Backpressure**         | 구독자가 감당할 수 있는 만큼만 요청 (`request(n)`)            |
| **Non-blocking & async** | 흐름 전체가 논블로킹, 비동기                               |
| **표준 명세**                | Reactive Streams API (Java 9부터 `Flow` API에 포함) |

*참조자료 : [내 블로그](https://velog.io/@kim00ngjun_0112/%EC%9E%90%EB%B0%94%EC%9D%98-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D#1-%EC%9E%90%EB%B0%94-flow-%ED%81%B4%EB%9E%98%EC%8A%A4)*

